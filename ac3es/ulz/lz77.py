# -*- coding: utf-8 -*-
#  This file is part of AC3ES Tools.
#
#  AC3ES Tools is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  AC3ES Tools is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with AC3ES Tools.  If not, see <http://www.gnu.org/licenses/>.


import collections
import mmap
import logging


class SlidingWindow:
    """
    A generic implementation of the sliding window for lz77, the real
    compression is done by UlzWriter, this class is for analyze the
    file and create the jump/run values.
    """
    look_ahead_buffer_size = None
    search_buffer_size = None
    no_compression = False

    search_buffer = None
    look_ahead_buffer = None

    lab_idx = -1

    min_run = 3
    min_match = 3
    longest_run = 0
    longest_jump = 0

    compressed_data = []

    def __init__(self,
                 filename,
                 search_buffer_size=1024,
                 look_ahead_buffer_size=32,
                 no_compression=False,
                 min_run=3,
                 min_match=3):
        """
        It's important to define the search_buffer_size and
        look_ahead_buffer_size, those values creates the corrent
        jump/run in order to be saved from the UlzWriter.

        The config values are get from the statistics of the ulz files
        and by reading the output generated by the decompressor.
        """

        self.look_ahead_buffer_size = look_ahead_buffer_size
        self.search_buffer_size = search_buffer_size
        self.no_compression = no_compression
        self.min_match = min_match
        self.min_run = min_run
        with open(filename, 'r+b') as f:
            self.stream = mmap.mmap(f.fileno(), 0)
        self.file_size = len(self.stream)

    def advance(self, steps=1):
        """
        Advance the window by n steps
        """
        self.lab_idx += steps
        lab_lower = self.lab_idx
        lab_upper = self.lab_idx + self.look_ahead_buffer_size
        self.look_ahead_buffer = self.stream[lab_lower:lab_upper]
        sb_lower = max(0, self.lab_idx - self.search_buffer_size)
        sb_upper = self.lab_idx
        self.search_buffer = self.stream[sb_lower:sb_upper]

    def search(self):
        """
        Search the data from look_ahead_buffer into the search_buffer
        """
        if self.no_compression:
            return self.add_uncompressed()
        for limit in range(len(self.look_ahead_buffer), 0, -1):
            token = self.look_ahead_buffer[0:limit]
            found = self.search_buffer.find(token)
            if found >= 0:
                run = limit
                # We look if our search_buffer edge can compress the look_ahead_buffer
                if self.search_buffer.endswith(token) and found == self.search_buffer.rfind(token):
                    ring_token = collections.deque(token)
                    extra_run = 0
                    for char in self.look_ahead_buffer:
                        if run + extra_run < self.look_ahead_buffer_size and ring_token[0] == char:
                            extra_run = extra_run + 1
                            ring_token.rotate(1)
                        else:
                            break
                    if extra_run >= self.min_run:
                        run += extra_run - len(token)
                if run >= self.min_run:
                    jmp = len(self.search_buffer) - found
                    self.compressed_data.append({
                        'type': 'compressed',
                        'jmp': jmp,
                        'run': run
                    })
                    logging.debug("\t".join([
                        'C ',
                        str(self.lab_idx),
                        '',
                        str(len(self.search_buffer) - found),
                        str(run)
                    ]))
                    self.longest_run = max(run, self.longest_run)
                    self.longest_jump = max(jmp, self.longest_jump)
                    return run
        return self.add_uncompressed()

    def add_uncompressed(self):
        """
        Add uncompressed byte
        """
        self.compressed_data.append({
            'type': 'uncompressed',
            'token': self.look_ahead_buffer[0]
        })
        logging.debug(
            "\t".join([
                'U ',
                str(self.lab_idx),
                str(hex(self.look_ahead_buffer[0])),
                '', '']))
        return 1

    def run(self):
        """
        Run the compression
        """
        self.advance()
        while self.look_ahead_buffer:
            run = self.search()
            self.advance(run)
